        Оценка сложности решений задачи N ферзей
    (Сугубо личное мнение, посему наверняка не вполне верное)

# 1. Перечисление всех вариантов (`enumeration.py`)  
Сложность: O(N! * N²)  
Обоснование: Перебираются все перестановки ферзей (`N!`). Для каждой перестановки проверяется корректность диагоналей (O(N²)). Хорошо работает только для N ≤ 9


# 2. Рекурсивное решение (`recursive.py`)
Сложность: O(N!) 
Обоснование: Используется рекурсия с проверкой конфликтов по столбцам и диагоналям. Невозможные варианты отсеиваются на ранних стадиях (бэктрекинг). Работает для N ≤ 12 за разумное время


# 3. Оптимизированное решение (`optimized.py`) 
Сложность: O(N!) 
Обоснование: Используются множества для занятых колонок и диагоналей, проверка безопасности выполняется за O(1). Работает быстро для N ≤ 14